#include "lcd.h"
#include "spi.h"
#include "time.h"
#include "cfg.h"
#include "ff.h"
#include "math.h"

const u8 LcdUsbLogo[]={/*16*55*/
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0xC0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x80,0x01,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7F,0xE0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x00,0x3F,0xC0,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x07,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x3F,0xC0,0x00,0x00,0x0F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0xF0,0x00,0x00,0x1F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0xFC,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x03,0xFF,0xFE,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x07,0xFF,0xFE,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x80,0x00,
	0x07,0xFF,0xFF,0x00,0x01,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xE0,0x00,
	0x0F,0xFF,0xFF,0x00,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xF0,0x00,
	0x0F,0xFF,0xFF,0x80,0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFC,0x00,
	0x1F,0xFF,0xFF,0x80,0x0F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x00,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xC0,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,
	0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x80,
	0x0F,0xFF,0xFF,0x80,0x00,0x00,0x03,0xF0,0x00,0x00,0x00,0x00,0x00,0x01,0xFE,0x00,
	0x0F,0xFF,0xFF,0x80,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x01,0xF8,0x00,
	0x07,0xFF,0xFF,0x00,0x00,0x00,0x01,0xFC,0x00,0x00,0x00,0x00,0x00,0x01,0xF0,0x00,
	0x07,0xFF,0xFF,0x00,0x00,0x00,0x00,0xFE,0x00,0x00,0x00,0x00,0x00,0x01,0xC0,0x00,
	0x03,0xFF,0xFE,0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,
	0x01,0xFF,0xFC,0x00,0x00,0x00,0x00,0x3F,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x01,0xFF,0xF8,0x00,0x00,0x00,0x00,0x1F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x7F,0xF0,0x00,0x00,0x00,0x00,0x0F,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x1F,0xC0,0x00,0x00,0x00,0x00,0x07,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3F,0x80,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0xC0,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0xF8,0x00,0x00,0x00,
};

//4x5点阵字库
const u8 LcdMiniNum[][4]={
	{0x1f,0x11,0x1f,0x00},//0
	{0x09,0x1f,0x01,0x00},//1
	{0x17,0x15,0x1d,0x00},//2
	{0x15,0x15,0x1f,0x00},//3
	{0x1c,0x04,0x1f,0x00},//4
	{0x1d,0x15,0x17,0x00},//5
	{0x1f,0x15,0x17,0x00},//6
	{0x10,0x10,0x1f,0x00},//7
	{0x1f,0x15,0x1f,0x00},//8
	{0x1d,0x15,0x1f,0x00},//9
	{0x01,0x00,0x00,0x00},//.
	{0x04,0x04,0x04,0x00},//-
	{0x07,0x04,0x07,0x04},//m
	{0x07,0x00,0x0f,0x01},//
	{0x07,0x01,0x0f,0x00},//W
	{0x00,0x00,0x00,0x00},//SPACE
	{0x04,0x0e,0x04,0x00},//+
	{0x01,0x06,0x18,0x00},///
	{0x0a,0x00,0x00,0x00},//:
	{0x0a,0x00,0x00,0x00},//
	{0x0a,0x00,0x00,0x00},//
	{0x0a,0x00,0x00,0x00},//
	{0x0a,0x00,0x00,0x00},//22
	{0x0f,0x14,0x0F,0x00},//A
	{0x1f,0x15,0x0f,0x00},//B
	{0x1f,0x11,0x11,0x00},//C
	{0x1f,0x11,0x0E,0x00},//D
	{0x1f,0x15,0x15,0x00},//E
	{0x1f,0x14,0x14,0x00},//F
	{0x1f,0x11,0x17,0x00},//G
	{0x1f,0x04,0x1f,0x00},//H
	{0x00,0x1F,0x00,0x00},//I
	{0x03,0x01,0x1F,0x00},//J
	{0x1F,0x04,0x1B,0x00},//K
	{0x1F,0x01,0x01,0x00},//L
	{0x1F,0x08,0x1f,0x00},//M
	{0x1F,0x0e,0x1f,0x00},//N
	{0x0E,0x11,0x0E,0x00},//O
	{0x1f,0x14,0x1C,0x00},//P
	{0x1f,0x11,0x0E,0x00},//Q
	{0x1f,0x16,0x1D,0x00},//R
	{0x1d,0x15,0x17,0x00},//S
	{0x10,0x1F,0x10,0x00},//T
	{0x1f,0x01,0x1f,0x00},//U
	{0x1e,0x01,0x1e,0x00},//V
	{0x1f,0x02,0x1f,0x00},//W
	{0x1B,0x04,0x1B,0x00},//X
	{0x18,0x07,0x18,0x00},//Y
	{0x13,0x15,0x19,0x00},//Z
};

const u8 LcdTxRun[]={0x1C,0x3E,0x7F,0x63,0x7F,0x3E,0x1C};//开机运行时间图标
const u8 LcdClock[]={0x1C,0x22,0x41,0x79,0x49,0x22,0x1C};//时钟图标
const u8 LcdThunder[]={0x00,0x08,0x19,0x2A,0x4C,0x08,0x00};//电池闪电图标
const u8 LcdArrowFocus[]={0x1C,0x00,0x1C,0x00,0x1C,0x00,0x7F,0x3E,0x1C,0x08};//被光标选中的菜单项有子菜单时显示的图标
const u8 LcdArrow[]={0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x3E,0x1C,0x08};//未被光标选中的菜单项有子菜单时显示的图标
const u8 LcdValueArrow[][6]={
	{0x24,0x66,0xE7,0x66,0x24,0x00},//位于最大最小值之间
	{0x04,0x66,0x67,0x66,0x04,0x00},//达到最大值
	{0x20,0x66,0xE6,0x66,0x20,0x00},//达到最小值
};
const u8 LcdEditArrow[]={0x10,0x30,0x70,0x30,0x10,0x00};//修改模型名时被选中的字符显示的图标

const u8 LcdRevBarArrow[]={0x7C,0x7C,0x38,0x38,0x10,0x10};//修改通道反向时指向状态条的图标

u8 LCD_RAM[LCD_RAM_SIZE];//LCD显示缓冲区
static FIL file_lcd;//BMP文件
u8 BMP_ROW_BUF[16];//BMP图片行数据缓冲区

u32 LightStartTmr;//背光时间计时器

//LCD背光初始化
void LCD_BL_Cof(void)
{
	//LCD_BL-------------PB1(TIM3_CH4)
	TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
    TIM_OCInitTypeDef  TIM_OCInitStructure;
    GPIO_InitTypeDef GPIO_InitStructure;
	
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);//开启外设TIM3
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//开启外设GPIOB
	
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init(GPIOB,&GPIO_InitStructure);
	
	TIM_TimeBaseStructure.TIM_Period = 0x02CF;  //72MHz/(719+1)=10us
	TIM_TimeBaseStructure.TIM_Prescaler = 0x00; //72MHz/(0+1)=72MHz 
	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
	TIM_TimeBaseInit(TIM3,&TIM_TimeBaseStructure);
	
	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; //选择定时器模式:TIM脉冲宽度调制模式1
 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能
	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高
	
	TIM_OC4Init(TIM3,&TIM_OCInitStructure);
	
	TIM_OC4PreloadConfig(TIM3,TIM_OCPreload_Enable);  //使能TIM3在CCR4上的预装载寄存器
	
	TIM_SetCompare4(TIM3,0);
	
	TIM_Cmd(TIM3,ENABLE);  //使能TIM3
}

//背光亮度调整(0~100)
void LCD_SetBL(u8 brightness)
{
	u16 compara_value = 0;
	
	if(brightness>100)
	{
		compara_value = 720;
	}
	else
	{
		compara_value = 7.2*brightness;
	}
	TIM_SetCompare4(TIM3,compara_value);
}
																		
/***********************/
/*    写数据到LCD      */
/***********************/
void LCD_Write_Data(unsigned char data)
{
	SET_LCD_RS();
	SPI2_Write_Byte(data);
}
/***********************/
/*    写命令到LCD      */
/***********************/
void LCD_Write_Com(unsigned char com)
{
	CLR_LCD_RS();
	SPI2_Write_Byte(com);
}
/***********************/
/*     初始化LCD       */
/***********************/
void LCD_Init(void)
{
	LCD_BL_Cof();
	
	CLR_LCD_CS();
	LCD_Write_Com(0xe2);  /*软复位*/ 
	DelayMs(5); 
	LCD_Write_Com(0x2c);  /*升压步聚 1*/ 
	DelayMs(5);   
	LCD_Write_Com(0x2e);  /*升压步聚 2*/ 
	DelayMs(5); 
	LCD_Write_Com(0x2f);  /*升压步聚 3*/ 
	DelayMs(5); 
	LCD_Write_Com(0x24);  /*粗调对比度，可设置范围 0x20～0x27*/ 
	LCD_Write_Com(0x81);  /*微调对比度*/ 
	LCD_Write_Com(0x27);  /*微调对比度的值，可设置范围 0x00～0x3f*/ 
	LCD_Write_Com(0xa2);  /*1/9 偏压比（bias）*/ 
	LCD_Write_Com(0xc0);  /*行扫描顺序：COM0-->COM63*/ 
	LCD_Write_Com(0xa1);  /*列扫描顺序：SEG0-->SEG127*/ 
	LCD_Write_Com(0x40);  /*起始行：第一行开始*/ 
	LCD_Write_Com(0xaf);  /*开显示*/ 
	SET_LCD_CS();
}

//对比度调节(0~10)
void LCD_SetContrast(u8 contrast)
{
	contrast = 29+contrast*2;
	CLR_LCD_CS();
	LCD_Write_Com(0x81);  /*微调对比度*/ 
	LCD_Write_Com(contrast);  /*微调对比度的值，可设置范围 0x00～0x3f*/ 
	SET_LCD_CS();
}

/***********************/
/*     清屏LCD         */
/***********************/
void LCD_Clr_All(void) 
{ 
	u16 i; 
	for(i=0;i<LCD_RAM_SIZE;i++)
	{
		LCD_RAM[i] = 0x00;
	}
} 
/***********************/
/*     显示所有点阵    */
/***********************/
void LCD_Disp_All(void)
{
	u16 i; 
	for(i=0;i<LCD_RAM_SIZE;i++)
	{
		LCD_RAM[i] = 0xFF;
	}
}

/***********************/
/*     刷新显示    		*/
/***********************/
void LCD_Refresh_Frame(void)
{
	u8 i,j;
	static u8 page = 0;
	
	CLR_LCD_CS();
	for(i=page;i<page+2;i++)//每次刷新四分之一屏
	{
		LCD_Write_Com(0xb0+i);	//写页地址0~7
		LCD_Write_Com(0x10);	//写列地址高四位
		LCD_Write_Com(0x00+4);	//写列地址低四位
		for(j=0;j<LCD_WIDTH;j++)
		{
			LCD_Write_Data(LCD_RAM[i*LCD_WIDTH+j]);
		}
	}
	SET_LCD_CS();
	
	page += 2;
	if(page>=8)	page = 0;
}

//显示一个点,color:点的颜色黑/白
void LCD_Disp_Dot(u16 row,u16 column,u8 color)
{
	u8 page;
	if(row>63||column>127)
	{
		return;
	}
	page = row/8;
	if(color)
	{
		LCD_RAM[page*LCD_WIDTH+column] |= 1<<(row%8);
	}
	else
	{
		LCD_RAM[page*LCD_WIDTH+column] &= ~(1<<(row%8));
	}
}

//显示6*8点阵
void Disp_Graphic_6x8(u16 row,u16 column,u8 *dp,u8 underline,u8 reverse) 
{ 
	u16 i,j;
	u8 data;
	for(j=0;j<6;j++)
	{
		data = dp[j];
		if(underline)
		{
			data |= 0x80;
		}
		if(reverse)
		{
			data = ~data;
		}
		for(i=0;i<8;i++)
		{
			LCD_Disp_Dot(row+i,column+j,(data>>i)&0x01);
		}
	}
}

//在6*8方格中显示5*7点阵字符
void Disp_String_6x8(u16 row,u16 column,u8 *text,u8 underline,u8 reverse) 
{ 
	FRESULT res;
	UINT br;
	unsigned char i = 0; 
	unsigned char fontbuf[6]; 
	unsigned int addr_offset=0;
	
	res = f_open(&file_lcd,"font/ASC5x7.bin",FA_OPEN_EXISTING|FA_READ);
	if(res!=FR_OK)
	{
		f_close(&file_lcd);
		return;
	}     
	while((text[i]>0x00)) 
	{ 
		if((text[i]>=0x20)&&(text[i]<=0x7e))   
		{  
			addr_offset = (text[i]-0x20)*8;
			res = f_lseek(&file_lcd,addr_offset);
			res = f_read(&file_lcd,fontbuf,6,&br);
			Disp_Graphic_6x8(row,column,fontbuf,underline,reverse); 
			i+=1; 
			column+=6; 
		} 
		else 
		{
			i++;   
		}
	}
	f_close(&file_lcd);
}

//显示12*12点阵,与以上显示方式不同，因为字库取模方式不同
void Disp_Graphic_12x12(u16 row,u16 column,u8 *dp,u8 underline,u8 reverse)
{
	u16 i,j,k;
	u8 data;
	
	for(i=0;i<12;i++)
	{
		for(j=0;j<2;j++)
		{
			data = dp[2*i+j];
			if(underline&&(i==11))
			{
				data |= 0xFF;
			}
			if(reverse)
			{
				data = ~data;
			}
			if(j==0)
			{
				for(k=0;k<8;k++)
				{
					LCD_Disp_Dot(row+i,column+k,(data<<k)&0x80);
				}
			}
			else
			{
				for(k=0;k<4;k++)
				{
					LCD_Disp_Dot(row+i,column+k+8,(data<<k)&0x80);
				}
			}
		}
	}
}

void Disp_Graphic_6x12(u16 row,u16 column,u8 *dp,u8 underline,u8 reverse)
{
	u16 i,k;
	u8 data;
	
	for(i=0;i<12;i++)
	{
		data = dp[i];
		if(underline&&(i==11))
		{
			data |= 0xFF;
		}
		if(reverse)
		{
			data = ~data;
		}
		for(k=0;k<8;k++)
		{
			LCD_Disp_Dot(row+i,column+k,(data<<k)&0x80);
		}
	}
}

//在12*12方格中显示11*11GB2312汉字
void Disp_GB2312_String(u16 row,u16 column,u8 *text,u8 underline,u8 reverse)
{
	FRESULT res;
	UINT br;
	unsigned char i = 0; 
	unsigned char fontbuf[24]; 
	unsigned int addr_offset=0;
	
	res = f_open(&file_lcd,"font/HZK12.bin",FA_OPEN_EXISTING|FA_READ);
	if(res!=FR_OK)
	{
		f_close(&file_lcd);
		return;
	} 
	while((text[i]>0x00)) 
	{ 
		if((text[i]>=0x20)&&(text[i]<=0x7E))//ASCII码编码范围0x20~0x7E
		{
			addr_offset = (text[i]-0x20)*12;
			res = f_lseek(&file_lcd,addr_offset);
			res = f_read(&file_lcd,fontbuf,12,&br);
			Disp_Graphic_6x12(row,column,fontbuf,underline,reverse); 
			i+=1; 
			column+=6; 
		}
		else if(((text[i]>=0xB0)&&(text[i]<0xF7))&&(text[i+1]>=0xA1))//汉字编码范围0xB0A1~0xF7FE
		{
			addr_offset = 1140+(text[i]-0xB0)*2256+(text[i+1]-0xA1)*24;
			res = f_lseek(&file_lcd,addr_offset);
			res = f_read(&file_lcd,fontbuf,24,&br);
			Disp_Graphic_12x12(row,column,fontbuf,underline,reverse); 
			i+=2; 
			column+=12; 
		}
		else 
		{
			i++;  
		}			
	}
	f_close(&file_lcd);
}

//(column,row)是图片左上角的坐标
void LCD_Disp_BMP(u16 row,u16 column,char *pic_name)
{
	u16 i,j;
	FRESULT res;
	UINT br;
	WORD fileType;
	BITMAPFILEHEADER bitHead;
    BITMAPINFOHEADER bitInfoHead;
	u16 quarter,remain,byte_length;
	
	res = f_open(&file_lcd,pic_name,FA_OPEN_EXISTING|FA_READ);
	if(res!=FR_OK)
	{
		return;
	}     
    f_read(&file_lcd,&fileType,sizeof(WORD),&br);
	if(fileType != 0x4d42)
	{
		f_close(&file_lcd);
		return;
	}
	f_read(&file_lcd,&bitHead,sizeof(tagBITMAPFILEHEADER),&br);
    f_read(&file_lcd,&bitInfoHead,sizeof(BITMAPINFOHEADER),&br);
	if(bitInfoHead.biWidth>128||bitInfoHead.biHeight>64)
	{
		f_close(&file_lcd);
		return;
	}
	remain = bitInfoHead.biWidth%32;
	quarter = bitInfoHead.biWidth-remain;
	byte_length = quarter/8+((remain)?4:0);//每行实际占用的字节数
	for(i=0;i<bitInfoHead.biHeight;i++)
	{
		f_read(&file_lcd,BMP_ROW_BUF,byte_length,&br);
		for(j=0;j<bitInfoHead.biWidth;j++)
		{
			if(BMP_ROW_BUF[j/8]&(0x80>>(j%8)))
			{
				LCD_Disp_Dot(row+bitInfoHead.biHeight-i-1,column+j,1);
			}
		}
	}
	f_close(&file_lcd);
}

//画直线函数,端点坐标（x1,y1）,(x2,y2),以屏幕左上角为坐标原点
void LCD_Draw_Line(s16 x1,s16 y1,s16 x2,s16 y2,u8 color)
{
	s16 x,y,xdev,ydev,delta;
	float k;
	xdev = (x1<x2)?(x2-x1):(x1-x2);
	ydev = (y1<y2)?(y2-y1):(y1-y2);
	
	LCD_Disp_Dot(y1,x1,color);
	if((xdev==0)&&(ydev==0))
	{
		return;
	}
	else if(xdev>=ydev)
	{
		k = (float)(y2-y1)/(x2-x1);
		delta = (x2-x1)/xdev;
		x = x1;
		while(x!=x2)
		{
			x += delta;
			y = y1+k*(x-x1);
			LCD_Disp_Dot(y,x,color);
		}
	}
	else
	{
		k = (float)(x2-x1)/(y2-y1);
		delta = (y2-y1)/ydev;
		y = y1;
		while(y!=y2)
		{
			y += delta;
			x = x1+k*(y-y1);
			LCD_Disp_Dot(y,x,color);
		}
	}
} 

//绘制矩形，任意两对角线坐标（x1，y1），（x2，y2），以屏幕左上角为坐标原点
void LCD_Draw_Rect(s16 x1,s16 y1,s16 x2,s16 y2,u8 color)
{
	if(x1==x2||y1==y2)
	{
		return;
	}
	LCD_Draw_Line(x1,y1,x2,y1,color);
	LCD_Draw_Line(x2,y1,x2,y2,color);
	LCD_Draw_Line(x2,y2,x1,y2,color);
	LCD_Draw_Line(x1,y2,x1,y1,color);
}

//填充矩形区域,两对角线坐标（x1，y1），（x2，y2），以屏幕左上角为坐标原点,color:填充的颜色
void LCD_Fill_Rect(s16 x1,s16 y1,s16 x2,s16 y2,u8 color)
{
	s16 y,xdev,ydev,delta;
	xdev = (x1<x2)?(x2-x1):(x1-x2);
	ydev = (y1<y2)?(y2-y1):(y1-y2);
	
	if(xdev==0||ydev==0)
	{
		return;
	}
	delta = (y2-y1)/ydev;
	LCD_Draw_Line(x1,y1,x2,y1,color);
	y = y1;
	while(y!=y2)
	{
		y += delta;
		LCD_Draw_Line(x1,y,x2,y,color);
	}
}

/////////////////////////////////////////////
//
// 标准数字显示函数
//
//（x,y）数字坐上脚的坐标
// value 要显示的整数
// n     显示几位,n=0自动计算位数
// dot   显示小数点后几位,为0则不显示小数点
// plus  在value为正数是否显示+号,不论是否显示,都会预留符号的宽度
// ar    为0时左对齐,为1时右对齐输出
void LcdDrawInt(u16 x,u16 y,s16 value,u8 n,u8 dot,u8 plus,u8 ar,u8 underline,u8 reverse)
{
	u8 sz = 0;//是否显示0
	u8 minus[2] = {' ',0};//符号
	u8 ascii[2] = {0,0};
	s16 v;
	u8 w;
	s16 mask=1;
	u8 i;

	if(value<0) 
	{
		minus[0] = '-';
		value = -value;
	}
	else if(value>0)
	{
	    if(plus)	minus[0] = '+';
	}
	
	//计算数字位数
	v = value;
	if(n==0)	for(n=0;v;n++,v/=10);
	if(n<=dot)	n=dot+1;	//如果位数不足小数点，要补上0.xx
	
	//计算像素宽度
	w=n*6;
	if(dot!=0) w+=2;	//如果有小数点，还要加2位宽度
	if(plus!=0xff)	w+=6;//为了对齐，符号位始终预留
	
	//计算掩码
	for(i=0;i<n-1;i++) mask*=10;
	
	//如果是右对齐，需要重新计算起始位置
	if(ar)	x-=w;
    
     //绘制符号
    if(plus!=0xff)
    {
		Disp_GB2312_String(y,x,minus,underline,reverse);
		x+=6;
	}
    
	//开始绘制数字
	for(i=0;i<n;i++)
	{
		v=value/mask%10;
		if(i==n-1)	sz=1;//如果已经是最后一位，则0也要显示
		if(i==n-1-dot && dot)
		{
			sz = 1;//如果已达到小数点，则0也要显示
			ascii[0] = v + '0';
			Disp_GB2312_String(y,x,ascii,underline,reverse);
			x+=6;
    		Disp_GB2312_String(y,x,".",underline,reverse);
			x+=2;
		}
		else
		{
			if(v)	sz=1;	//如果此位非0，则后续0都要显示
			else	if(!sz)	v=' '-'0';//如果是零且未置位az，则将0替换成空格
			ascii[0] = v + '0';
			Disp_GB2312_String(y,x,ascii,underline,reverse);
			x+=6;			
		} 
		mask/=10;
    }
}

//绘制垂直样线，起点(x,y),向y增大方向绘制，mask:线样式，n:线的长度
void LcdDrawMaskY(u16 x,u16 y,u8 mask,u8 n,u8 reverse)
{
	u8 j,c;
	u8  mv=1<<n;
	
	if(reverse)	mask = ~mask;
	for(j=0;j<n;j++)
	{
		mv>>=1;
		c=mask&mv;
		LCD_Disp_Dot(y+j,x,c);
	}
}

//绘制水平样线，起点(x,y),向x增大方向绘制，mask:线样式，n:线的长度
void LcdDrawMaskX(u16 x,u16 y,u8 mask,u8 n,u8 reverse)
{
	u8  j,c;
	u8  mv=1<<n;
	
	if(reverse)	mask = ~mask;
	for(j=0;j<n;j++)
	{
		mv>>=1;
		c=mask&mv;
		LCD_Disp_Dot(y,x+j,c);
	}
}

//reverse:反显标志
void LcdDrawMiniNum(u16 x,u16 y,u8 num,u8 reverse)
{
	int i;
	for(i=0;i<4;i++)
	{
		LcdDrawMaskY(x+i,y,LcdMiniNum[num][i],5,reverse);
    }	
}

//（x,y）数字坐上脚的坐标
// value 要显示的整数
// n     显示几位,n=0自动计算位数
// dot   显示小数点后几位,为0则不显示小数点
// plus  在value为正数是否显示+号,不论是否显示,都会预留符号的宽度
// ar    为0时左对齐,为1时右对齐输出
// reverse 反显标志
void LcdDrawMiniInt(u16 x,u16 y,s16 value,u8 n,u8 dot,u8 plus,u8 ar,u8 reverse)
{
	s16 v;
	u8 w;
	u8 minus = LCD_MN_SP;
	s16 mask = 1;
	u8 i;
	u8 sz = 0;//是否显示0
	
	//确定符号位
	if(value<0) 
	{
		minus = LCD_MN_MINUS;
		value = -value;
	}
	else if(value>0)
	{
	    if(plus)	minus = LCD_MN_PLUS;
	}
	
	//计算数字位数
	v = value;
	if(n==0)	for(n=0;v;n++,v/=10);
	if(n<=dot)	n=dot+1;	//如果位数不足小数点，要补上0.xx
	
	//计算像素宽度
	w=n*4;
	if(dot!=0) w+=2;	//如果有小数点，还要加2位宽度
	if(plus!=0xff)	w+=4;//为了对齐，符号位始终预留
	
	//计算掩码
	for(i=0;i<n-1;i++) 
	{
		mask*=10;
	}
	
	//如果是右对齐，需要重新计算起始位置
	if(ar)	x-=w;
    
    //绘制符号
    if(plus!=0xff)
    {
    	LcdDrawMiniNum(x,y,minus,reverse); 
		x+=4;
	}
    
	//开始绘制数字
	for(i=0;i<n;i++)
	{
		v=value/mask%10;
		if(i==n-1)	sz=1;//如果已经是最后一位，则0也要显示
		if(i==n-1-dot && dot)
		{
			sz=1;//如果已达到小数点，则0也要显示
			LcdDrawMiniNum(x,y,v,reverse);			
			x+=4;
    		LcdDrawMiniNum(x,y,LCD_MN_DOT,reverse);	
			x+=2;
		}
		else
		{
			if(v)	sz=1;	//如果此位非0，则后续0都要显示
			else if(!sz)	v=LCD_MN_SP;//如果是零且未置位az，则将0替换成空格
			LcdDrawMiniNum(x,y,v,reverse);			
			x+=4;
		} 
		mask/=10;
    }
}

//显示迷你英文字符
void LcdDrawMiniEng(u16 x,u16 y,char *eng,u8 reverse)
{
	char c;
	
	while(*eng)
	{
		c = *eng;
		if(c>='a' && c<='z') c=c-'a'+'A';
		if(c>='A' && c<='Z')
		{
			LcdDrawMiniNum(x,y,LCD_MN_CHAR(c),reverse);
		}
		else if(c>='0' && c<='9')
		{
			LcdDrawMiniNum(x,y,c-'0',reverse);
		}
		else if(c==' ')
		{
			LcdDrawMiniNum(x,y,LCD_MN_SP,reverse);
		}
		else
		{
			LcdDrawMiniNum(x,y,c,reverse);
		}
		
		eng++;
		x+=4;
	}
}

//BMP编码的图标显示函数
void LcdDrawIcon(u16 x,u16 y,u16 w,u16 h,const u8 *icon)
{
	u16 i,j;
	u16 quarter,remain,byte_length;
	
	remain = w%32;
	quarter = w-remain;
	byte_length = quarter/8+((remain)?4:0);//每行实际占用的字节数
	for(i=0;i<h;i++)
	{
		for(j=0;j<w;j++)
		{
			if(icon[byte_length*i + j/8]&(0x80>>(j%8)))
			{
				LCD_Disp_Dot(y+h-i-1,x+j,1);
			}
		}
	}
}

//绘制USB LOGO
void LcdDrawUsbLogo(u16 x,u16 y)
{
	u16 i,j,k;
	for(i=0;i<55;i++)
	{
		for(j=0;j<16;j++)
		{
			for(k=0;k<8;k++)
			{
				LCD_Disp_Dot(y+i,x+j*8+k,LcdUsbLogo[i*16+j]&(0x80>>k));
			}
		}
	}
}

void LcdDrawTxRun(u16 x,u16 y)
{
	u8 i;
	for(i=0;i<7;i++)
	{
		LcdDrawMaskY(x+i,y,LcdTxRun[i],7,0);
    }	
}


void LcdDrawThunder(u16 x,u16 y)
{
	u8 i;
	for(i=0;i<7;i++)
	{
		LcdDrawMaskY(x+i,y,LcdThunder[i],7,0);
    }	
}

void LcdDrawClock(u16 x,u16 y)
{
	u8 i;
	for(i=0;i<7;i++)
	{
		LcdDrawMaskY(x+i,y,LcdClock[i],7,0);
    }	
}

void LcdDrawArrow(u16 x,u16 y,u8 focus)
{
	u8 i;
	if(focus)
	{
		for(i=0;i<10;i++)
		{
			LcdDrawMaskY(x+i,y,LcdArrowFocus[i],7,1);
		}
	}
	else
	{
		for(i=0;i<10;i++)
		{
			LcdDrawMaskY(x+i,y,LcdArrow[i],7,0);
		}
	}
}

//state:0-位于最大最小值之间,1-达到最大值,2-达到最小值
void LcdDraw_ValueArrow(u16 x,u16 y,u8 state)
{
	Disp_Graphic_6x8(y,x,(u8 *)LcdValueArrow[state],0,1);
}

void LcdDraw_EditArrow(u16 x,u16 y)
{
	Disp_Graphic_6x8(y,x,(u8 *)LcdEditArrow,0,0);
}

void LcdDraw_RevBarArrow(u16 x,u16 y)
{
	Disp_Graphic_6x8(y,x,(u8 *)LcdRevBarArrow,0,0);
}

//LCD显示处理
void LCDHandler(void)
{
	static s16 txlight = 0;
	static s16 txcontrast = 0;
	
	LCD_Refresh_Frame();//刷新显示
	
	//背光
	if(TxSys.LightOff && (Time_NowMs()>(LightStartTmr+(u32)TxSys.LightOff*10000)))
	{
		LCD_SetBL(txlight=0);
	}
	else
	{
		if(txlight!=TxSys.Light)
		{
			txlight = TxSys.Light;
			LCD_SetBL(TxSys.Light*8);
		}
	}
	
	if(txcontrast!=TxSys.Contrast)
	{
		txcontrast=TxSys.Contrast;
		LCD_SetContrast(TxSys.Contrast);
	}
}

void Lcd_CloseFile(void)
{
	f_close(&file_lcd);
}
